---
layout: post
title: Python set
tags: [Python]
categories:
  - Python
date: 2023-02-14
---

## 집합(set)이란?

- set은 집합에 관련된 것을 처리하기 위해 만들어진 자료형
- set 키워드를 사용하거나 중괄호를 이용해서 표현할 수 있음.
- set 자료형은 중복을 허용하지 않음
- set() 생성자 함수를 이용해서 만들 수 있음
- {} 를 이용해서 만들 수 있음
- add() 메서드를 이용하여 추가가 가능
- update() 메서드를 이용하여 동시에 여러개 추가가 가능
- remove() 메서드를 이용하여 삭제가 가능
- copy() 메서드를 이용하여 복사가 가능
- clear() 메서드를 이용하여 모든 요소 삭제가 가능
- 순서가 없음
- mutable(=값이 변하는) 객체 임

❗ 순서가 없기 때문에 리스트나 튜플에서 사용했던 인덱싱이 불가능 함

```
s1 = set({1, 2, 3})
s2 = set([1, 2, 3])
s3 = set{1, 2, 3}
```

세개 다 같은 집합을 만듬

비어있는 집합을 만들기 위해서는

```
s4 = set()
```

이처럼 만들면 됨

## 파이썬 교집합, 합집합, 차집합, 집합이 같은지, 다른지

집합 자료형은 집합의 특징들을 메서드 혹은 연산자를 통해서 구할 수 있게 만들어져 있음.

✅ 교집합

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([4, 5, 6, 7, 8])

# 교집합 메서드 intersection
print(s1.ingersection(s2))

#교집합 연산자 &
print(s1 & s2)

```

결과

```
{4, 5}
{4, 5}
```

교집합을 구할때는 "intersection" 이라는 메서드를 이용하거나 "&"를 이용하여 집합의 교집합을 구할 수 있음

✅ 합집합

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([4, 5, 6, 7, 8])

# 합집합 메서드 union
print(s1.union(s2))

# 합집합 연산자 |
print(s1 | s2)
```

결과

```
{1, 2, 3, 4, 5, 6, 7, 8}
{1, 2, 3, 4, 5, 6, 7, 8}
```

합집합을 구할때는 "union" 이라는 메서드를 이용하거나 연산자를 이용하여 구할 수 있음

✅ 차집합

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([4, 5, 6, 7, 8])

# 차집합 메서드 difference
print(s1.difference(s2))
print(s2.difference(s1))

# 차집합 연산자
print(s1 - s2)
print(s2 - s1)
```

결과

```
{1, 2, 3}
{8, 6, 7}

------------------

{1, 2, 3}
{8, 6, 7}

```

순서가 바뀌어도 상관이 없는 교집합, 합집합과 달리 차집합은 순서가 상관이 있음. 차집합을 구할 때는 "difference" 메서드를 이용하거나 "-" 연산자를 이용해서 구할 수 있음

✅ 집합이 같은지

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([4, 5, 6, 7, 8])
s3 = {1, 2, 3, 4, 5}

if s1 == s2:
    print("s1과 s2은 같습니다")
else:
    print("s1과 s2은 다릅니다")


if s1 == s3:
    print("s1과 s3은 같습니다")
else:
    print("s1과 s3은 다릅니다")
```

집합은 순서가 상관이 없기 때문에 같은 요소만 들어있따면 같은 집합임. 집합의 모든 요소가 같을 때만 집합이 같은 것

✅ 집합이 아예 다른지(같은 요소가 없음)

```
s1 = set([1, 2, 3, 4, 5])
s2 = set([4, 5, 6, 7, 8])
s3 = {1, 2, 3, 4, 5}
s4 = {6, 7, 8, 9, 10}

if s1.isdisjoint(s2):
    print("s1과 s2은 같은 요소가 하나도 없습니다")
else:
    print("s1과 s2은 같은 요소가 적어도 하나는 있습니다")

if s1.isdisjoint(s3):
    print("s1과 s3은 같은 요소가 하나도 없습니다")
else:
    print("s1과 s3은 같은 요소가 적어도 하나는 있습니다")

if s1.isdisjoint(s4):
    print("s1과 s4은 같은 요소가 하나도 없습니다")
else:
    print("s1과 s4은 같은 요소가 적어도 하나는 있습니다")
```

결과

```
s1과 s2은 같은 요소가 적어도 하나는 있습니다
s1과 s3은 같은 요소가 적어도 하나는 있습니다
s1과 s4은 같은 요소가 하나도 없습니다
```

집합이 다른 것은 사실 요소가 하나라도 다르면 다른 것임. 그것에 대한 검사는 !=으로 할 수 있음.  
여기서 확인하고 싶은 것은 집합에서 공통된 부분이 하나도 없다. 즉, 교집합이 없다. 아예 모든 요소가 다 다르다 임.
이것을 알고 싶을 때 사용하는 메서드는 "isdisjoint" 임

❗ 부분집합을 구하기 위해서는 issubsest 메서드를 이용

❗ 대칭 차집합을 구하기 위해서는 symmetric_difference 메서드 혹은 "^" 연산자를 이용

## 파이썬 집합 add, update, remove, discard, pop, clear, in, len

✅ set add - 요소 추가

```
s = {1, 2, 3}
print(f'set : {s}')

s.add('blockmask')
print(f'set : {s}')

s.add('blockmask') #중복 값
print(f'set : {s}')

s.add(4)
print(f'set : {s'})
```

결과

```
set : {1, 2, 3}
set : {1, 2, 3, 'blockask'}
set : {1, 2, 3, 'blockask'}
set : {1, 2, 3, 'blockask', 4}
```

set.add() 메서드를 이용하면 집합 내부에 원하는 값을 추가 할 수 있음.  
위 예제에서 확인 할 수 있든 중복 값을 넣어도 무시됨. 이는 집합의 특징인 "중복 제거" 에 의해 만들어진 결과이며, 중복된 값을 넣어도 오류가 발생하지 않음을 알 수 있음

✅ set update - 요소 여러개 추가

```
s = {1, 2, 3}
print(f'set: {s}')

s.update({'a', 'b', 'c'})
print(f'set : {s}')

s.update([11, 12, 13])
print(f'set: {s}')
```

결과

```
set : {1, 2, 3}
set : {1, 2, 3, 'b', 'c', 'a'}
set : {1, 2, 3, 'b', 11, 12, 13, 'c', 'a'}
```

set.update() 메서드를 이용하면 집합의 값을 한번에 여러개 추가 할 수 있음. 요소를 추가할 때 리스트를 뜻하는 대괄호[] 혹은 집합 자료형을 뜻하는 중괄호 {} 를 이용해서 추가함.

✅ set remove - 특정 요소 제거

```
s = {'kim', 'lee', 'park', 2, 3, 4}
print(f'집합 : {s}')

s.remove("kim")
print(f'집합 : {s}')

# 에러 발생
# s.remove("kim")
# print(f'집합 : {s}')
```

결과

```
집합 :  {2, 3, 4, 'lee', 'kim', 'park'}
집합 :  {2, 3, 4, 'lee', 'park'}
```

set.remove() 메서드를 이용하면 집합의 특정 요소를 제거할 수 있음. 하지만 지우려는 요소가 집합 안에 없는 경우에는 에러가 발생  
set.remove() 메서드는 아래와 같이 동작합  
set 내부에 값이 있으면 삭제  
set 내부에 값이 없으면 오류

✅ set discard - 특정 요소 안전하게 제거

```
s = {'kim', 'lee', 'park', 2, 3, 4}
print(f'집합 : {s}')

s.discard("lee")
print(f'집합 : {s}')

s.discard('lee')
print(f'집합 : {s}')
```

결과

```
집합 : {'park', 2, 3, 4, 'lee', 'kim'}
집합 : {'park', 2, 3, 4, 'kim'}
집합 : {'park', 2, 3, 4, 'kim'}
```

이렇게 set.discard() 메서드를 이용하면 안전하게 요소를 제거할 수 있음. 집합의 discard 메서드는 아래와 같이 동작함.  
집합 내부에 값이 있으면 삭제.  
집합 내부에 값이 없으면 아무일도 일어나지 않음

✅ set-pop - 임의의 요소를 갖고 온 후 제거

```
s = {'r', 'a', 'n', 'd', 'o', 'm'}
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

print(f'집합.pop() : {s.pop()}')
print(f'집합 : {s}')

# 이미 비어있는 집합이므로 pop 불가. error 발생
# print(f'집합.pop() : {s.pop()}')
# print(f'집합 : {s}')

```

결과

```
집합 : {'d', 'n', 'a', 'r', 'o', 'm'}

집합.pop() : d
집합 : {'n', 'a', 'r', 'o', 'm'}

집합.pop() : n
집합 : {'a', 'r', 'o', 'm'}

집합.pop() : a
집합 : {'r', 'o', 'm'}

집합.pop() : r
집합 : {'o', 'm'}

집합.pop() : o
집합 : {'m'}

집합.pop() : m
집합 : set()
```

이렇게 set.pop() 메서드를 사용하면 set의 임의의 요소 하나를 반환하고, 그 반환한 요소를 set에서 제거 함
여기서 알아야 할 것은 세가지 임.

- set.pop() 함수의 읨의의 요소 하나 반환, 반환한 요소 제거
- 임의의 요소라 하지만 자세히 보면 set 맨 앞에 있는 요소를 pop하고 제거하는 걸로 보임. 하지만 set 자료형이 순서가 없는 자료형이기 때문에 맨 앞의 요소라 해도, 그것이 실제로를 순서가 없는 것이므로 임의의 요소가 맞음.
- set이 비어있는 상태에서 pop() 메서드를 호출하면 에러가 발생하게 됨. 그러므로 len 내장함수 같은 걸 이용해서 집합이 비어있는지 확인한 후에 set.pop() 메서드를 사용하는 것이 안전함

✅ set clear - 모든 요소 제거

```
s = {'e', 'f', 'g', 11, 12, 13}
print(f'집합 s : {s}')

s.clear()
print(f'clear 후 집합 : {s}')
```

결과

```
집합 s : {'e', 'f', 11, 12, 13, 'g'}
clear 후 집합 : set()
```

집합.clear()를 이용해서 집합 내부의 모든 요소를 제거 할 수 있음. 모든 요소를 제거한 집합은 비어있는 집합이 되며, print를 했을 때 "set()"으로 표현 됨  
len()으로 집합의 길이를 검사하면 0이 나옴

✅ set in - 내부에 요소가 있는지 확인

```
s = {'a', 'b', 'c', 'd'}

if 'a' in s:
    print('집합 s 내부에 'a'가 존재합니다')
else:
    print('집합 s 내부에 'a'가 존재하지 않습니다')

if 'z' in s:
    print('집합 s 내부에 'z'가 존재합니다')
else:
    print('집합 s 내부에 'z'가 존재하지 않습니다')

```

결과

```
집합 s 내부에 'a'가 존재합니다
집합 s 내부에 'z'가 존재하지 않습니다
```

이렇게 파이썬의 in을 이용해서 집합 내부에 해당 요소가 있는지 확인 할 수 있음

✅ set len - 집합 길이 확인

```
# 집합 길이 확인
s = {1, 2, 3, 1, 2, 3}
print(f'집합 : {s}')
print(f'집합의 길이 : {len(s)}')
```

결과

```
집합 : {1, 2, 3}
집합의 길이 : 3
```

1, 2, 3, 1, 2, 3이 있지만 set으로 만드는 순간 중복이 제거 되어서 만들어짐. 그렇기 때문에 {1, 2, 3}이라는 집합이 생기고 그것을 len 내장함수를 이용해서 길이를 구하면 3이 나옴

## 파이썬 집합 예제

```
# 집합 중복 제거
print('1. 집합 선언시 중복 제거됨')
s1 = {1, 1, 2, 2, 3, 3, 'a', 'a', 'BlockDMask', 'BlockDMask', 'b'}
print(f"s1 : {s1}")


# 리스트 중복 제거 후 다시 리스트로
print()
print('2. 리스트 중복을 set으로 제거, 그 후 다시 리스트로')

result1 = [1, 1, 1, 1, 1, 'a', 'a', 'list', 'list', 1, 1, 1]
print(f'list = {result1}')

s2 = set(result1)
print(f'set(리스트) = {s2}')
print(f'list(집합) = {list(s2)}')


# 튜플 중복 제거 후 다시 리스트로
print()
print('3. 튜플 중복을 set으로 제거, 그 후 다시 리스트로')

result2 = (2, 2, 3, 3, 'blog', 'blog', 'blockdmask', 'blockdmask')
print(f'tuple = {result2}')

s3 = set(result2)
print(f'set(튜플) = {s3}')
print(f'tuple(집합) = {tuple(s3)}')
```

결과

```
1. 집합 선언시 중복 제거됨
s1 : {1, 2, 3, 'b', 'BlockDMask', 'a'}

2. 리스트 중복을 set으로 제거, 그 후 다시 리스트로
list = [1, 1, 1, 1, 1, 'a', 'a', 'list', 'list', 1 1, 1]
set(리스트) = {1, 'list', 'a'}
list(집합) = {1, 'list', 'a'}

3. 튜플 중복을 set으로 제거, 그 후 다시 리스트로
tuple = (2, 2, 3, 3, 'blog', 'blog', 'blockdmask', 'blockdmask')
set(튜플) = {'blog', 'blockdmask', 2, 3}
tuple(집합) =  ('blog', 'blockdmask', 2, 3)
```

이렇게 리스트나 튜플의 중복을 제거하기 위해 set 자료형을 이용하기도 함.
리스트와 튜플에 순서가 있어도 set 자료형으로 바뀐후에 가기 때문에 set 자료형으로 변경될 때 순서가 바뀔 수도 있음. 그렇기 때문에 다시 본인의 리스트, 튜플로 돌아왔을 때 중복은 제거가 되지만 순서는 보장할 수 없음

### 📌 참고 블로그

<br>

[파이썬 집합](https://blockdmask.tistory.com/451)

[파이썬 set](https://wikidocs.net/20625)
